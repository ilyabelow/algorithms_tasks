#include "IGraph.h"#include "ListGraph.h"#include "MatrixGraph.h"#include "SetGraph.h"#include "ArcGraph.h"#include <vector>#include <string>#include <iostream>//I SWEAR I'll rewrite this code to GTest as soon as I'll have free time to study it properly :(//============================================================//                       UTILITIES//============================================================void insertion_sort(std::vector<int> &vector) {    for (int i = 1; i < vector.size(); ++i) {        int swapped = vector[i];        int j = i;        while (j != 0 && vector[j - 1] > swapped) {            vector[j] = vector[j - 1];            j--;        }        vector[j] = swapped;    }}//Returns a pointer to a graph of specified derived type and sizeIGraph *construct_graph(const std::string &name, const int &vertex) {    if (name == "ListGraph") {        return new ListGraph(vertex);    }    if (name == "MatrixGraph") {        return new MatrixGraph(vertex);    }    if (name == "SetGraph") {        return new SetGraph(vertex);    }    if (name == "ArcGraph") {        return new ArcGraph(vertex);    }    return nullptr;}//Returns a pointer to a copy of the graph of specified derived typeIGraph *copy_graph(const std::string &name, const IGraph *original) {    if (name == "ListGraph") {        return new ListGraph(original);    }    if (name == "MatrixGraph") {        return new MatrixGraph(original);    }    if (name == "SetGraph") {        return new SetGraph(original);    }    if (name == "ArcGraph") {        return new ArcGraph(original);    }    return nullptr;}//Pair to 'new's in construct_graphvoid decompose_graph(IGraph *graph) {    delete graph;}//General function for constructing a graph from specified adjacency_matrix and then comparing//it's next or previous vertices with the right ones. Tests AddEdge, GetNextVertices, GetPrevVerticesbool test_neighbors(std::string &type, //wheather to test next o prev                    std::string &graph_name, //type og graph                    int graph_size, //amount of vertices of the tested graph                    std::vector<std::vector<int>> &desired_edges, //what adjacency_matrix need to be added                    std::vector<std::vector<int>> &expect_neib) { //what neighbors need to be if graph works correctly    //Constructing test sample    IGraph *graph = construct_graph(graph_name, graph_size);    for (int i = 0; i < desired_edges.size(); ++i) {        graph->AddEdge(desired_edges[i][0], desired_edges[i][1]);    }    //Retrieving neighbors    std::vector<std::vector<int>> real_neib;    real_neib.resize(graph_size);    for (int i = 0; i < graph_size; ++i) {        if (type == "next") {            graph->GetNextVertices(i, real_neib[i]);        }        if (type == "prev") {            graph->GetPrevVertices(i, real_neib[i]);        }        //GetNextVertices and GetPrevVertices return unsorted arrays        insertion_sort(real_neib[i]);    }    //Comparing    for (int i = 0; i < graph_size; ++i) {        if (expect_neib[i] != real_neib[i]) {            std::cout << "test_fill_" << graph_size << "_" << graph_name << "_" << type << " FAILED\n";            decompose_graph(graph);            return false;        }    }    std::cout << "test_fill_" << graph_size << "_" << graph_name << "_" << type << " PASSED\n";    decompose_graph(graph);    return true;}//General function for tests that checks that the only non const function of IGraph AddEdge doesn't change//graph size (just in case)bool test_vertices(std::string &graph_name, //type of graph                   int graph_size, //amount of vertices of the tested graph                   std::vector<std::vector<int>> &desired_edges) { //what adjacency_matrix need to be added    //Constructing test sample    IGraph *graph = construct_graph(graph_name, graph_size);    for (int i = 0; i < desired_edges.size(); ++i) {        graph->AddEdge(desired_edges[i][0], desired_edges[i][1]);    }    if (graph->VerticesCount() != graph_size) {        std::cout << "test_count_" << graph_size << "_" << graph_name << " FAILED\n";        decompose_graph(graph);        return false;    }    std::cout << "test_count_" << graph_size << "_" << graph_name << " PASSED\n";    decompose_graph(graph);    return true;}//General function for constructing a graph from specified adjacency_matrix and then comparing//it's next or previous vertices with the right ones. Tests AddEdge, GetNextVertices, GetPrevVerticesbool test_equality(std::string &graph_name, //type og graph                   int graph_size, //amount of vertices of the tested graph                   std::vector<std::vector<int>> &desired_edges) { //what adjacency_matrix need to be added    //Constructing original graph    IGraph *original = construct_graph("ListGraph", graph_size);    for (int i = 0; i < desired_edges.size(); ++i) {        original->AddEdge(desired_edges[i][0], desired_edges[i][1]);    }    //Retrieving next and prev    std::vector<std::vector<int>> original_next;    original_next.resize(graph_size);    for (int i = 0; i < graph_size; ++i) {        original->GetNextVertices(i, original_next[i]);        //GetNextVertices and GetPrevVertices return unsorted arrays        insertion_sort(original_next[i]);    }    std::vector<std::vector<int>> original_prev;    original_prev.resize(graph_size);    for (int i = 0; i < graph_size; ++i) {        original->GetPrevVertices(i, original_prev[i]);        insertion_sort(original_prev[i]);    }    //Copy    IGraph *copy = copy_graph(graph_name, original);    //Retrieving next and prev    std::vector<std::vector<int>> copy_next;    copy_next.resize(graph_size);    for (int i = 0; i < graph_size; ++i) {        copy->GetNextVertices(i, copy_next[i]);        insertion_sort(copy_next[i]);    }    std::vector<std::vector<int>> copy_prev;    copy_prev.resize(graph_size);    for (int i = 0; i < graph_size; ++i) {        copy->GetPrevVertices(i, copy_prev[i]);        insertion_sort(copy_prev[i]);    }    //Comparing    for (int i = 0; i < graph_size; ++i) {        if (copy_prev[i] != original_prev[i] || copy_next[i] != original_next[i]) {            std::cout << "test_copy_" << graph_size << "_" << graph_name << " FAILED\n";            decompose_graph(original);            decompose_graph(copy);            return false;        }    }    std::cout << "test_copy_" << graph_size << "_" << graph_name << " PASSED\n";    decompose_graph(original);    decompose_graph(copy);    return true;}//============================================================//                         TESTS//============================================================//Test 1 to check Get<>Vertices on graph with 5 vertices//GetPrevVerticesbool test_fill5_prev(std::string &graph_name) {    std::string type = "prev";    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {1, 0},                                            {2, 0},                                            {3, 0},                                            {0, 4}};    std::vector<std::vector<int> > expect = {{1, 2, 3},                                             {0},                                             {1},                                             {},                                             {0}};    return test_neighbors(type, graph_name, 5, edges, expect);}//GetNextVerticesbool test_fill5_next(std::string &graph_name) {    std::string type = "next";    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {1, 0},                                            {2, 0},                                            {3, 0},                                            {0, 4}};    std::vector<std::vector<int> > expect = {{1, 4},                                             {0, 2},                                             {0},                                             {0},                                             {}};    return test_neighbors(type, graph_name, 5, edges, expect);}//Test 2 to check Get<>Vertices on complete graph with 3 vertices//GetPrevVerticesbool test_fill3_prev(std::string &graph_name) {    std::string type = "prev";    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 0},                                            {1, 2},                                            {2, 1},                                            {2, 0},                                            {0, 2}};    std::vector<std::vector<int> > expect = {{1, 2},                                             {0, 2},                                             {0, 1},};    return test_neighbors(type, graph_name, 3, edges, expect);}//GetNextVerticesbool test_fill3_next(std::string &graph_name) {    std::string type = "next";    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 0},                                            {1, 2},                                            {2, 1},                                            {2, 0},                                            {0, 2}};    std::vector<std::vector<int> > expect = {{1, 2},                                             {0, 2},                                             {0, 1},};    return test_neighbors(type, graph_name, 3, edges, expect);}//Test 3 to check Get<>Vertices on cycle graph with 6 vertices//GetPrevVerticesbool test_fill6_prev(std::string &graph_name) {    std::string type = "prev";    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {2, 3},                                            {3, 4},                                            {4, 5},                                            {5, 0}};    std::vector<std::vector<int> > expect = {{5},                                             {0},                                             {1},                                             {2},                                             {3},                                             {4},};    return test_neighbors(type, graph_name, 6, edges, expect);}//GetNextVerticesbool test_fill6_next(std::string &graph_name) {    std::string type = "next";    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {2, 3},                                            {3, 4},                                            {4, 5},                                            {5, 0}};    std::vector<std::vector<int> > expect = {{1},                                             {2},                                             {3},                                             {4},                                             {5},                                             {0},};    return test_neighbors(type, graph_name, 6, edges, expect);}//Test 4 to check Get<>Vertices on graph with 2 vertices with loops//GetPrevVerticesbool test_fill2_prev(std::string &graph_name) {    std::string type = "prev";    std::vector<std::vector<int> > edges = {{0, 1},                                            {0, 0},};    std::vector<std::vector<int> > expect = {{0},                                             {0},};    return test_neighbors(type, graph_name, 2, edges, expect);}//GetNextVerticesbool test_fill2_next(std::string &graph_name) {    std::string type = "next";    std::vector<std::vector<int> > edges = {{0, 1},                                            {0, 0},};    std::vector<std::vector<int> > expect = {{0, 1},                                             {},};    return test_neighbors(type, graph_name, 2, edges, expect);}//Test 5 to check Get<>Vertices on empty graph with 4 vertices//GetPrevVerticesbool test_fill4_prev(std::string &graph_name) {    std::string type = "prev";    std::vector<std::vector<int> > edges = {};    std::vector<std::vector<int> > expect = {{},                                             {},                                             {},                                             {},};    return test_neighbors(type, graph_name, 4, edges, expect);}//GetNextVerticesbool test_fill4_next(std::string &graph_name) {    std::string type = "next";    std::vector<std::vector<int> > edges = {};    std::vector<std::vector<int> > expect = {{},                                             {},                                             {},                                             {},};    return test_neighbors(type, graph_name, 4, edges, expect);}//============================================================//Test 6 to check VerticesCount of an empty graphbool test_count256_same(std::string &graph_name) {    std::vector<std::vector<int> > edges = {};    return test_vertices(graph_name, 256, edges);}//Test 7 to check VerticesCount of an empty graphbool test_count0_same(std::string &graph_name) {    std::vector<std::vector<int> > edges = {};    return test_vertices(graph_name, 0, edges);}//Test 8 to check VerticesCount of an empty graphbool test_count111_same(std::string &graph_name) {    std::vector<std::vector<int> > edges = {};    return test_vertices(graph_name, 111, edges);}//Test 9 to check VerticesCount of a complete graph with 4 verticesbool test_count4_same(std::string &graph_name) {    std::vector<std::vector<int> > edges = {{0, 1},                                            {0, 2},                                            {0, 3},                                            {1, 2},                                            {1, 3},                                            {1, 0},                                            {2, 0},                                            {2, 1},                                            {2, 3},                                            {3, 0},                                            {3, 1},                                            {3, 2},};    return test_vertices(graph_name, 4, edges);}//Test 10 to check VerticesCount of the graph from test 1bool test_count5_same(std::string &graph_name) {    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {1, 0},                                            {2, 0},                                            {3, 0},                                            {0, 4}};    return test_vertices(graph_name, 5, edges);}//============================================================//Test 11 to check copy constructor for graph from test 1bool test_copy5_equal(std::string &graph_name) {    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {1, 0},                                            {2, 0},                                            {3, 0},                                            {0, 4}};    return test_equality(graph_name, 5, edges);}//Test 12 to check copy constructor for graph from test 2bool test_copy3_equal(std::string &graph_name) {    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 0},                                            {1, 2},                                            {2, 1},                                            {2, 0},                                            {0, 2}};    return test_equality(graph_name, 3, edges);}//Test 13 to check copy constructor for graph from test 3bool test_copy6_equal(std::string &graph_name) {    std::vector<std::vector<int> > edges = {{0, 1},                                            {1, 2},                                            {2, 3},                                            {3, 4},                                            {4, 5},                                            {5, 0}};    return test_equality(graph_name, 6, edges);}//Test 14 to check copy constructor for graph from test 4bool test_copy2_equal(std::string &graph_name) {    std::vector<std::vector<int> > edges = {{0, 1},                                            {0, 0},};    return test_equality(graph_name, 2, edges);}//Test 15 to check copy constructor for graph from test 5bool test_copy4_equal(std::string &graph_name) {    std::vector<std::vector<int> > edges = {};    return test_equality(graph_name, 4, edges);}//============================================================//                          RUN//============================================================//Apply all the existing tests to specified type of graphbool full_test_graph(std::string name) {    std::cout << "\nTEST " << name << std::endl;    //fill tests    test_fill6_prev(name);    test_fill5_prev(name);    test_fill4_prev(name);    test_fill3_prev(name);    test_fill2_prev(name);    test_fill6_next(name);    test_fill5_next(name);    test_fill4_next(name);    test_fill3_next(name);    test_fill2_next(name);    std::cout << std::endl;    //vertices count test    test_count256_same(name);    test_count0_same(name);    test_count111_same(name);    test_count4_same(name);    test_count5_same(name);    std::cout << std::endl;    //copy constructor test    test_copy5_equal(name);    test_copy3_equal(name);    test_copy6_equal(name);    test_copy2_equal(name);    test_copy4_equal(name);    std::cout << std::endl;}int main() {    full_test_graph("ListGraph");    full_test_graph("MatrixGraph");    full_test_graph("SetGraph");    full_test_graph("ArcGraph");    return 0;}